export default {
  app: {
    title: 'Visualizador de Linguagens & Computação',
    subtitle: 'Simulador Interativo de Autômatos e Máquinas de Turing',
    by: 'por',
    madeBy: 'feito por',
  },
  tabs: {
    dfa: 'AFD',
    nfa: 'AFN',
    enfa: 'ε-AFN',
    pda: 'AP',
    turing: 'Máquina de Turing',
  },
  editor: {
    states: 'Estados',
    addState: 'Adicionar Estado',
    stateLabel: 'Rótulo',
    initial: 'Inicial',
    accepting: 'Aceitação',
    remove: 'Remover',
    alphabet: 'Alfabeto',
    alphabetPlaceholder: 'Digite um símbolo e pressione Enter',
    transitions: 'Transições',
    addTransition: 'Adicionar Transição',
    from: 'De',
    to: 'Para',
    symbol: 'Símbolo',
    epsilon: 'ε',
    stackTop: 'Topo da Pilha',
    stackPush: 'Empilhar',
    read: 'Ler',
    write: 'Escrever',
    move: 'Mover',
    inputAlphabet: 'Alfabeto de Entrada',
    stackAlphabet: 'Alfabeto da Pilha',
    tapeAlphabet: 'Alfabeto da Fita',
    initialStackSymbol: 'Símbolo Inicial da Pilha',
    blankSymbol: 'Símbolo Branco',
    acceptanceMode: 'Modo de Aceitação',
    finalState: 'Estado Final',
    emptyStack: 'Pilha Vazia',
    both: 'Ambos',
    rejectStates: 'Estados de Rejeição',
    rejecting: 'Rejeição',
    noStates: 'Nenhum estado definido. Adicione um estado para começar.',
    noTransitions: 'Nenhuma transição definida.',
  },
  simulation: {
    inputString: 'String de Entrada',
    inputPlaceholder: 'Digite a string para testar...',
    emptyString: 'ε (vazia)',
    run: 'Executar',
    step: 'Passo',
    pause: 'Pausar',
    resume: 'Continuar',
    reset: 'Reiniciar',
    speed: 'Velocidade',
    slow: 'Lento',
    fast: 'Rápido',
    status: 'Status',
    idle: 'Parado',
    running: 'Executando',
    paused: 'Pausado',
    accepted: 'Aceita',
    rejected: 'Rejeitada',
    stuck: 'Travado (sem transição)',
    log: 'Log de Transições',
    noLog: 'Execute uma simulação para ver o log de transições.',
    step_read: 'Passo {step}: Lê \'{symbol}\' no estado {state}',
    step_move: '→ Move para estado {target}',
    step_nfa_move: '→ Estados ativos: {states}',
    step_epsilon: '→ ε-fechamento adiciona: {states}',
    step_stack_op: '→ Desempilha \'{pop}\', Empilha \'{push}\'',
    step_tape_op: '→ Escreve \'{write}\', Move {dir}',
    step_initial: 'Inicia no estado {state}',
    step_accept: 'String ACEITA no estado {state}',
    step_reject: 'String REJEITADA no estado {state}',
    step_stuck: 'TRAVADO: Sem transição para \'{symbol}\' no estado {state}',
  },
  persistence: {
    save: 'Salvar',
    load: 'Carregar',
    export: 'Exportar JSON',
    import: 'Importar JSON',
    saved: 'Salvo com sucesso!',
    loaded: 'Carregado com sucesso!',
    noSave: 'Nenhum dado salvo encontrado.',
    importError: 'Formato de arquivo inválido.',
    clearAll: 'Limpar Tudo',
    clearConfirm: 'Limpar todas as definições? Isso não pode ser desfeito.',
  },
  explanation: {
    dfa: {
      title: 'Autômato Finito Determinístico (AFD)',
      body: 'Um AFD processa a entrada um símbolo por vez. De cada estado, há exatamente uma transição para cada símbolo do alfabeto. A string é aceita se o AFD terminar em um estado de aceitação após ler toda a entrada.',
    },
    nfa: {
      title: 'Autômato Finito Não-determinístico (AFN)',
      body: 'Um AFN pode ter múltiplas transições para o mesmo símbolo de um estado, ou nenhuma transição. A string é aceita se qualquer caminho possível através do autômato alcançar um estado de aceitação.',
    },
    enfa: {
      title: 'AFN com ε-transições (ε-AFN)',
      body: 'Um ε-AFN estende o AFN com transições epsilon (ε) — transições que podem ser tomadas sem consumir nenhum símbolo de entrada. Após cada movimento, o ε-fechamento é calculado para encontrar todos os estados alcançáveis.',
    },
    pda: {
      title: 'Autômato com Pilha (AP)',
      body: 'Um AP estende um autômato finito com uma pilha. Cada transição pode ler um símbolo, desempilhar da pilha e empilhar símbolos. APs podem reconhecer linguagens livres de contexto como {aⁿbⁿ}.',
    },
    turing: {
      title: 'Máquina de Turing (MT)',
      body: 'Uma Máquina de Turing possui uma fita infinita e um cabeçote de leitura/escrita. Cada passo lê o símbolo atual, escreve um novo símbolo e move o cabeçote para a esquerda ou direita. MTs podem reconhecer linguagens recursivamente enumeráveis.',
    },
  },
  examples: {
    loadExample: 'Carregar Exemplo',
    title: 'Exemplos Predefinidos',
    dfa: {
      endsWith01: {
        name: 'Termina com "01"',
        description: 'Aceita strings binárias que terminam com "01". Alfabeto: {0, 1}.',
      },
      evenZeros: {
        name: 'Número par de 0s',
        description: 'Aceita strings binárias com um número par de zeros (incluindo zero zeros).',
      },
      divisibleBy3: {
        name: 'Binário divisível por 3',
        description: 'Interpreta a entrada como um número binário e aceita se for divisível por 3.',
      },
    },
    nfa: {
      contains01: {
        name: 'Contém "01"',
        description: 'Aceita strings binárias que contêm a substring "01" em algum lugar.',
      },
      endsWith10or01: {
        name: 'Termina com "10" ou "01"',
        description: 'Aceita strings binárias terminando com "10" ou "01". Demonstra ramificação não-determinística.',
      },
    },
    enfa: {
      optionalA: {
        name: '"a" opcional antes de "b"',
        description: 'Aceita "b" ou "ab". A ε-transição permite pular o "a" opcional.',
      },
      unionAstarBstar: {
        name: 'a* ∪ b*',
        description: 'Aceita strings apenas de a\'s ou apenas de b\'s (ou vazia). Usa ε-transições para ramificar em dois caminhos.',
      },
    },
    pda: {
      anbn: {
        name: 'aⁿbⁿ',
        description: 'Linguagem livre de contexto clássica: número igual de a\'s seguido de número igual de b\'s.',
      },
      balancedParens: {
        name: 'Parênteses balanceados',
        description: 'Aceita strings de parênteses corretamente aninhados como "(())" e "()()".',
      },
    },
    turing: {
      binaryIncrement: {
        name: 'Incremento binário',
        description: 'Soma 1 a um número binário na fita. Ex: "101" → "110", "111" → "1000".',
      },
      palindrome: {
        name: 'Verificador de palíndromo',
        description: 'Aceita palíndromos sobre {a, b} comparando o primeiro e último caracteres repetidamente.',
      },
      unaryAddition: {
        name: 'Adição unária',
        description: 'Soma dois números unários separados por "+". Ex: "11+111" → "11111" (2+3=5).',
      },
    },
  },
  formalDef: {
    title: 'Definição Formal',
    empty: 'Defina estados e alfabeto para ver a definição formal.',
    transitionFunction: 'Função de Transição',
    tooltips: {
      Q: 'Conjunto finito de estados',
      sigma: 'Alfabeto de entrada',
      delta: 'Função de transição',
      q0: 'Estado inicial',
      F: 'Conjunto de estados de aceitação/finais',
      gamma: 'Alfabeto da pilha',
      gammaT: 'Alfabeto da fita',
      Z0: 'Símbolo inicial da pilha',
      qAccept: 'Estado de aceitação',
      qReject: 'Estado de rejeição',
      epsilon: 'String vazia (epsilon)',
      emptySet: 'Conjunto vazio',
      powerSet: 'Conjunto das partes de Q',
      mapsTo: 'Mapeia para',
      cartesian: 'Produto cartesiano',
      union: 'União de conjuntos',
    },
  },
  validation: {
    noStartState: 'Nenhum estado inicial definido.',
    noAcceptStates: 'Nenhum estado de aceitação definido.',
    missingTransitions: 'AFD requer transições para cada par (estado, símbolo).',
    duplicateTransition: 'Transição duplicada do estado {state} com \'{symbol}\'.',
    invalidState: 'Transição referencia estado indefinido: {state}.',
    invalidSymbol: 'Transição usa símbolo \'{symbol}\' que não está no alfabeto.',
    ready: 'Definição válida. Pronto para simular.',
  },
}
