export default {
  app: {
    title: 'Languages & Computation Visualizer',
    subtitle: 'Interactive Automata & Turing Machine Simulator',
    by: 'by',
    madeBy: 'made by',
  },
  tabs: {
    dfa: 'DFA',
    nfa: 'NFA',
    enfa: 'ε-NFA',
    pda: 'PDA',
    turing: 'Turing Machine',
  },
  editor: {
    states: 'States',
    addState: 'Add State',
    stateLabel: 'Label',
    initial: 'Initial',
    accepting: 'Accepting',
    remove: 'Remove',
    alphabet: 'Alphabet',
    alphabetPlaceholder: 'Type a symbol and press Enter',
    transitions: 'Transitions',
    addTransition: 'Add Transition',
    from: 'From',
    to: 'To',
    symbol: 'Symbol',
    epsilon: 'ε',
    stackTop: 'Stack Top',
    stackPush: 'Stack Push',
    read: 'Read',
    write: 'Write',
    move: 'Move',
    inputAlphabet: 'Input Alphabet',
    stackAlphabet: 'Stack Alphabet',
    tapeAlphabet: 'Tape Alphabet',
    initialStackSymbol: 'Initial Stack Symbol',
    blankSymbol: 'Blank Symbol',
    acceptanceMode: 'Acceptance Mode',
    finalState: 'Final State',
    emptyStack: 'Empty Stack',
    both: 'Both',
    rejectStates: 'Reject States',
    rejecting: 'Rejecting',
    noStates: 'No states defined yet. Add a state to begin.',
    noTransitions: 'No transitions defined yet.',
  },
  simulation: {
    inputString: 'Input String',
    inputPlaceholder: 'Enter string to test...',
    emptyString: 'ε (empty)',
    run: 'Run',
    step: 'Step',
    pause: 'Pause',
    resume: 'Resume',
    reset: 'Reset',
    speed: 'Speed',
    slow: 'Slow',
    fast: 'Fast',
    status: 'Status',
    idle: 'Idle',
    running: 'Running',
    paused: 'Paused',
    accepted: 'Accepted',
    rejected: 'Rejected',
    stuck: 'Stuck (no transition)',
    log: 'Transition Log',
    noLog: 'Run a simulation to see the transition log.',
    step_read: 'Step {step}: Read \'{symbol}\' in state {state}',
    step_move: '→ Move to state {target}',
    step_nfa_move: '→ Active states: {states}',
    step_epsilon: '→ ε-closure adds: {states}',
    step_stack_op: '→ Pop \'{pop}\', Push \'{push}\'',
    step_tape_op: '→ Write \'{write}\', Move {dir}',
    step_initial: 'Start in state {state}',
    step_accept: 'String ACCEPTED in state {state}',
    step_reject: 'String REJECTED in state {state}',
    step_stuck: 'STUCK: No transition for \'{symbol}\' in state {state}',
  },
  persistence: {
    save: 'Save',
    load: 'Load',
    export: 'Export JSON',
    import: 'Import JSON',
    saved: 'Saved successfully!',
    loaded: 'Loaded successfully!',
    noSave: 'No saved data found.',
    importError: 'Invalid file format.',
    clearAll: 'Clear All',
    clearConfirm: 'Clear all definitions? This cannot be undone.',
  },
  explanation: {
    dfa: {
      title: 'Deterministic Finite Automaton (DFA)',
      body: 'A DFA processes input one symbol at a time. From each state, there is exactly one transition for each alphabet symbol. The string is accepted if the DFA ends in an accepting state after reading all input.',
    },
    nfa: {
      title: 'Non-deterministic Finite Automaton (NFA)',
      body: 'An NFA can have multiple transitions for the same symbol from a state, or no transition at all. The string is accepted if any possible path through the automaton reaches an accepting state.',
    },
    enfa: {
      title: 'NFA with ε-transitions (ε-NFA)',
      body: 'An ε-NFA extends the NFA with epsilon (ε) transitions — transitions that can be taken without consuming any input symbol. After each move, the epsilon closure is computed to find all reachable states.',
    },
    pda: {
      title: 'Pushdown Automaton (PDA)',
      body: "A PDA extends a finite automaton with a stack. Each transition can read a symbol, pop from the stack, and push symbols onto the stack. PDAs can recognize context-free languages like {'{'}aⁿbⁿ{'}'}.",
    },
    turing: {
      title: 'Turing Machine (TM)',
      body: 'A Turing Machine has an infinite tape and a read/write head. Each step reads the current symbol, writes a new symbol, and moves the head left or right. TMs can recognize recursively enumerable languages.',
    },
  },
  examples: {
    loadExample: 'Load Example',
    title: 'Predefined Examples',
    dfa: {
      endsWith01: {
        name: 'Ends with "01"',
        description: "Accepts binary strings ending with \"01\". Alphabet: {'{'}0, 1{'}'}.",
      },
      evenZeros: {
        name: 'Even number of 0s',
        description: 'Accepts binary strings with an even number of zeros (including zero zeros).',
      },
      divisibleBy3: {
        name: 'Binary divisible by 3',
        description: 'Interprets input as a binary number and accepts if it is divisible by 3.',
      },
    },
    nfa: {
      contains01: {
        name: 'Contains "01"',
        description: 'Accepts binary strings that contain the substring "01" somewhere.',
      },
      endsWith10or01: {
        name: 'Ends with "10" or "01"',
        description: 'Accepts binary strings ending with either "10" or "01". Demonstrates non-deterministic branching.',
      },
    },
    enfa: {
      optionalA: {
        name: 'Optional "a" before "b"',
        description: 'Accepts "b" or "ab". The ε-transition lets it skip the optional "a".',
      },
      unionAstarBstar: {
        name: 'a* ∪ b*',
        description: 'Accepts strings of only a\'s or only b\'s (or empty). Uses ε-transitions to branch into two paths.',
      },
    },
    pda: {
      anbn: {
        name: 'aⁿbⁿ',
        description: 'Classic context-free language: equal number of a\'s followed by equal number of b\'s.',
      },
      balancedParens: {
        name: 'Balanced parentheses',
        description: 'Accepts strings of properly nested parentheses like "(())" and "()()".',
      },
    },
    turing: {
      binaryIncrement: {
        name: 'Binary increment',
        description: 'Adds 1 to a binary number on the tape. E.g. "101" → "110", "111" → "1000".',
      },
      palindrome: {
        name: 'Palindrome checker',
        description: "Accepts palindromes over {'{'}a, b{'}'} by comparing first and last chars repeatedly.",
      },
      unaryAddition: {
        name: 'Unary addition',
        description: 'Adds two unary numbers separated by "+". E.g. "11+111" → "11111" (2+3=5).',
      },
    },
  },
  formalDef: {
    title: 'Formal Definition',
    empty: 'Define states and alphabet to see the formal definition.',
    transitionFunction: 'Transition Function',
    tooltips: {
      Q: 'Finite set of states',
      sigma: 'Input alphabet',
      delta: 'Transition function',
      q0: 'Initial/start state',
      F: 'Set of accepting/final states',
      gamma: 'Stack alphabet',
      gammaT: 'Tape alphabet',
      Z0: 'Initial stack symbol',
      qAccept: 'Accept state',
      qReject: 'Reject state',
      epsilon: 'Empty string (epsilon)',
      emptySet: 'Empty set',
      powerSet: 'Power set of Q',
      mapsTo: 'Maps to',
      cartesian: 'Cartesian product',
      union: 'Set union',
    },
  },
  validation: {
    noStartState: 'No start state defined.',
    noAcceptStates: 'No accept states defined.',
    missingTransitions: 'DFA requires transitions for every (state, symbol) pair.',
    duplicateTransition: 'Duplicate transition from {state} on \'{symbol}\'.',
    invalidState: 'Transition references undefined state: {state}.',
    invalidSymbol: 'Transition uses symbol \'{symbol}\' not in alphabet.',
    ready: 'Definition is valid. Ready to simulate.',
  },
}
